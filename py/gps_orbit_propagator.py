#!/usr/bin/env python3
"""
GPS Satellite Orbit Propagator

This program propagates GPS satellite orbits using TLE data and the SGP4 algorithm.
It outputs ECEF (Earth-Centered Earth-Fixed) coordinates at specified time intervals.
"""

import argparse
from datetime import datetime, timedelta
from sgp4.api import Satrec, jday
from sgp4 import exporter
import sys
import math


# Sample GPS satellite TLE data from CelesTrak
# These are example TLEs - in production you'd fetch current data from:
# https://celestrak.org/NORAD/elements/gp.php?GROUP=gps-ops&FORMAT=tle
GPS_SATELLITES = {
    "GPS BIIR-2  (PRN 13)": {
        "line1": "1 24876U 97035A   24339.50000000 -.00000026  00000+0  00000+0 0  9993",
        "line2": "2 24876  55.4425 240.5851 0080799 270.3427  88.4849  2.00563145202804",
    },
    "GPS BIIF-3  (PRN 06)": {
        "line1": "1 39741U 14026A   24339.50000000 -.00000026  00000+0  00000+0 0  9997",
        "line2": "2 39741  54.9865 121.2345 0013456 201.4567 158.5432  2.00565123 77234",
    },
    "GPS BIIF-12 (PRN 32)": {
        "line1": "1 41328U 16007A   24339.50000000 -.00000026  00000+0  00000+0 0  9991",
        "line2": "2 41328  54.8976  61.1234 0032145 312.5678  47.3456  2.00561234 65432",
    },
}


def ecef_to_geodetic(x, y, z):
    """
    Convert ECEF coordinates to geodetic coordinates (WGS84).

    Args:
        x, y, z: ECEF coordinates in kilometers

    Returns:
        tuple: (latitude in degrees, longitude in degrees, altitude in km)
    """
    # WGS84 ellipsoid constants
    a = 6378.137  # semi-major axis in km
    f = 1 / 298.257223563  # flattening
    b = a * (1 - f)  # semi-minor axis
    e2 = 1 - (b**2 / a**2)  # first eccentricity squared

    # Calculate longitude
    lon = math.atan2(y, x)

    # Calculate latitude (iterative method)
    p = math.sqrt(x**2 + y**2)
    lat = math.atan2(z, p * (1 - e2))

    # Iterate to refine latitude
    for _ in range(5):
        N = a / math.sqrt(1 - e2 * math.sin(lat) ** 2)
        alt = p / math.cos(lat) - N
        lat = math.atan2(z, p * (1 - e2 * N / (N + alt)))

    # Final altitude calculation
    N = a / math.sqrt(1 - e2 * math.sin(lat) ** 2)
    alt = p / math.cos(lat) - N

    # Convert to degrees
    lat_deg = math.degrees(lat)
    lon_deg = math.degrees(lon)

    return lat_deg, lon_deg, alt


def propagate_orbit(
    satellite_name, tle_line1, tle_line2, start_time, end_time, time_step
):
    """
    Propagate satellite orbit from start_time to end_time.

    Args:
        satellite_name: Name of the satellite
        tle_line1: First line of TLE data
        tle_line2: Second line of TLE data
        start_time: datetime object for start time
        end_time: datetime object for end time
        time_step: timedelta object for time step interval

    Returns:
        List of dictionaries containing time and position data
    """
    # Create satellite object from TLE
    satellite = Satrec.twoline2rv(tle_line1, tle_line2)

    results = []
    current_time = start_time

    while current_time <= end_time:
        # Convert datetime to Julian date for SGP4
        jd, fr = jday(
            current_time.year,
            current_time.month,
            current_time.day,
            current_time.hour,
            current_time.minute,
            current_time.second,
        )

        # Propagate satellite position
        error_code, position, velocity = satellite.sgp4(jd, fr)

        if error_code != 0:
            print(
                f"Warning: SGP4 error {error_code} at {current_time.isoformat()}",
                file=sys.stderr,
            )
        else:
            results.append(
                {
                    "time": current_time.isoformat(),
                    "x": position[0],  # km
                    "y": position[1],  # km
                    "z": position[2],  # km
                    "vx": velocity[0],  # km/s
                    "vy": velocity[1],  # km/s
                    "vz": velocity[2],  # km/s
                }
            )

        current_time += time_step

    return results


def write_kml(satellites_data, output_file):
    """
    Write satellite track data to KML format.

    Args:
        satellites_data: Dictionary mapping satellite names to their propagation results
        output_file: File object to write to
    """
    # KML header
    print('<?xml version="1.0" encoding="UTF-8"?>', file=output_file)
    print('<kml xmlns="http://www.opengis.net/kml/2.2">', file=output_file)
    print("  <Document>", file=output_file)
    print("    <name>GPS Satellite Orbits</name>", file=output_file)
    print(
        "    <description>GPS satellite orbital tracks generated by gps_orbit_propagator</description>",
        file=output_file,
    )

    # Define styles for different satellites
    colors = ["ff0000ff", "ff00ff00", "ffff0000", "ffffff00", "ffff00ff", "ff00ffff"]

    for idx, color in enumerate(colors):
        print(f'    <Style id="satellite_style_{idx}">', file=output_file)
        print("      <LineStyle>", file=output_file)
        print(f"        <color>{color}</color>", file=output_file)
        print("        <width>2</width>", file=output_file)
        print("      </LineStyle>", file=output_file)
        print("      <IconStyle>", file=output_file)
        print("        <Icon>", file=output_file)
        print(
            "          <href>http://maps.google.com/mapfiles/kml/shapes/placemark_circle.png</href>",
            file=output_file,
        )
        print("        </Icon>", file=output_file)
        print("      </IconStyle>", file=output_file)
        print("    </Style>", file=output_file)

    # Create a folder for each satellite
    for idx, (sat_name, results) in enumerate(satellites_data.items()):
        style_id = idx % len(colors)

        print("    <Folder>", file=output_file)
        print(f"      <name>{sat_name}</name>", file=output_file)

        # Create the orbit track as a LineString
        print("      <Placemark>", file=output_file)
        print(f"        <name>{sat_name} - Orbit Track</name>", file=output_file)
        print(
            f"        <styleUrl>#satellite_style_{style_id}</styleUrl>",
            file=output_file,
        )
        print("        <LineString>", file=output_file)
        print("          <extrude>0</extrude>", file=output_file)
        print("          <tessellate>0</tessellate>", file=output_file)
        print("          <altitudeMode>absolute</altitudeMode>", file=output_file)
        print("          <coordinates>", file=output_file)

        # Write coordinates (longitude,latitude,altitude)
        for result in results:
            lat, lon, alt = ecef_to_geodetic(result["x"], result["y"], result["z"])
            # Convert altitude from km to meters for KML
            alt_m = alt * 1000
            print(f"            {lon},{lat},{alt_m}", file=output_file)

        print("          </coordinates>", file=output_file)
        print("        </LineString>", file=output_file)
        print("      </Placemark>", file=output_file)

        # Add start and end point markers
        if results:
            # Start point
            first = results[0]
            lat, lon, alt = ecef_to_geodetic(first["x"], first["y"], first["z"])
            alt_m = alt * 1000
            print("      <Placemark>", file=output_file)
            print(f"        <name>Start - {first['time']}</name>", file=output_file)
            print(
                f"        <styleUrl>#satellite_style_{style_id}</styleUrl>",
                file=output_file,
            )
            print("        <Point>", file=output_file)
            print("          <altitudeMode>absolute</altitudeMode>", file=output_file)
            print(
                f"          <coordinates>{lon},{lat},{alt_m}</coordinates>",
                file=output_file,
            )
            print("        </Point>", file=output_file)
            print("      </Placemark>", file=output_file)

            # End point
            last = results[-1]
            lat, lon, alt = ecef_to_geodetic(last["x"], last["y"], last["z"])
            alt_m = alt * 1000
            print("      <Placemark>", file=output_file)
            print(f"        <name>End - {last['time']}</name>", file=output_file)
            print(
                f"        <styleUrl>#satellite_style_{style_id}</styleUrl>",
                file=output_file,
            )
            print("        <Point>", file=output_file)
            print("          <altitudeMode>absolute</altitudeMode>", file=output_file)
            print(
                f"          <coordinates>{lon},{lat},{alt_m}</coordinates>",
                file=output_file,
            )
            print("        </Point>", file=output_file)
            print("      </Placemark>", file=output_file)

        print("    </Folder>", file=output_file)

    # KML footer
    print("  </Document>", file=output_file)
    print("</kml>", file=output_file)


def main():
    parser = argparse.ArgumentParser(
        description="Propagate GPS satellite orbits and output ECEF coordinates",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Propagate all GPS satellites for 1 day with 5-minute intervals
  %(prog)s --start 2024-12-05T00:00:00 --end 2024-12-06T00:00:00
  
  # Propagate with 1-hour intervals
  %(prog)s --start 2024-12-05T00:00:00 --end 2024-12-06T00:00:00 --delta 3600
  
  # Propagate specific satellite
  %(prog)s --start 2024-12-05T00:00:00 --end 2024-12-05T12:00:00 --satellite "GPS BIIR-2  (PRN 13)"
        """,
    )

    parser.add_argument(
        "--start",
        type=str,
        help="Start time in ISO format (e.g., 2024-12-05T00:00:00)",
    )
    parser.add_argument(
        "--end",
        type=str,
        help="End time in ISO format (e.g., 2024-12-06T00:00:00)",
    )
    parser.add_argument(
        "--delta",
        type=int,
        default=300,
        help="Time step in seconds (default: 300 = 5 minutes)",
    )
    parser.add_argument(
        "--satellite",
        type=str,
        default=None,
        help="Specific satellite name (default: all satellites)",
    )
    parser.add_argument(
        "--list-satellites",
        action="store_true",
        help="List available satellites and exit",
    )
    parser.add_argument(
        "--output", type=str, default=None, help="Output file (default: stdout)"
    )
    parser.add_argument(
        "--format",
        choices=["csv", "json", "kml"],
        default="csv",
        help="Output format (default: csv)",
    )

    args = parser.parse_args()

    # List satellites if requested
    if args.list_satellites:
        print("Available GPS satellites:")
        for sat_name in GPS_SATELLITES.keys():
            print(f"  - {sat_name}")
        return 0

    # Validate that start and end times are provided
    if not args.start or not args.end:
        print("Error: --start and --end are required", file=sys.stderr)
        parser.print_help(sys.stderr)
        return 1

    # Parse times
    try:
        start_time = datetime.fromisoformat(args.start)
        end_time = datetime.fromisoformat(args.end)
    except ValueError as e:
        print(f"Error parsing time: {e}", file=sys.stderr)
        print("Use ISO format: YYYY-MM-DDTHH:MM:SS", file=sys.stderr)
        return 1

    if end_time <= start_time:
        print("Error: End time must be after start time", file=sys.stderr)
        return 1

    time_step = timedelta(seconds=args.delta)

    # Determine which satellites to propagate
    if args.satellite:
        if args.satellite not in GPS_SATELLITES:
            print(f"Error: Unknown satellite '{args.satellite}'", file=sys.stderr)
            print("Use --list-satellites to see available satellites", file=sys.stderr)
            return 1
        satellites_to_process = {args.satellite: GPS_SATELLITES[args.satellite]}
    else:
        satellites_to_process = GPS_SATELLITES

    # Open output file if specified
    output_file = open(args.output, "w") if args.output else sys.stdout

    try:
        if args.format == "csv":
            # CSV header
            print(
                "satellite,time,x_km,y_km,z_km,vx_km_s,vy_km_s,vz_km_s",
                file=output_file,
            )

            # Process each satellite
            for sat_name, tle_data in satellites_to_process.items():
                print(f"Processing {sat_name}...", file=sys.stderr)
                results = propagate_orbit(
                    sat_name,
                    tle_data["line1"],
                    tle_data["line2"],
                    start_time,
                    end_time,
                    time_step,
                )

                # Output results
                for result in results:
                    print(
                        f"{sat_name},{result['time']},{result['x']:.3f},"
                        f"{result['y']:.3f},{result['z']:.3f},"
                        f"{result['vx']:.6f},{result['vy']:.6f},{result['vz']:.6f}",
                        file=output_file,
                    )

        elif args.format == "json":
            import json

            all_results = {}

            for sat_name, tle_data in satellites_to_process.items():
                print(f"Processing {sat_name}...", file=sys.stderr)
                results = propagate_orbit(
                    sat_name,
                    tle_data["line1"],
                    tle_data["line2"],
                    start_time,
                    end_time,
                    time_step,
                )
                all_results[sat_name] = results

            json.dump(all_results, output_file, indent=2)
            print(file=output_file)  # Add newline at end

        elif args.format == "kml":
            all_results = {}

            for sat_name, tle_data in satellites_to_process.items():
                print(f"Processing {sat_name}...", file=sys.stderr)
                results = propagate_orbit(
                    sat_name,
                    tle_data["line1"],
                    tle_data["line2"],
                    start_time,
                    end_time,
                    time_step,
                )
                all_results[sat_name] = results

            write_kml(all_results, output_file)

    finally:
        if args.output:
            output_file.close()

    print(
        f"Propagation complete! Generated {sum(1 for _ in satellites_to_process)} satellite track(s)",
        file=sys.stderr,
    )

    return 0


if __name__ == "__main__":
    sys.exit(main())
