\documentclass{amsbook}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{courier}
\usepackage{latexsym}

\newtheorem{theorem}{Theorem}
\newtheorem{definition}{Definition}
\newtheorem{notation}{Notation}

\renewcommand*{\familydefault}{\rmdefault}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstnewenvironment{cpp}
{
 \bigskip                    
 \lstset{
 	language=C++, % choose the language of the code.
 	frame=single,
 	tabsize=2,
 	rulesepcolor=\color{gray},
 	rulecolor=\color{black},
  backgroundcolor=\color{backcolour},   
  commentstyle=\color{codegreen},
  keywordstyle=\color{magenta},
  numberstyle=\tiny\color{codegray},
  stringstyle=\color{codepurple},
  basicstyle=\ttfamily\footnotesize,
  breakatwhitespace=false,         
  breaklines=true,                 
  captionpos=b,                    
  keepspaces=true,                 
  numbers=left,                    
  numbersep=5pt,                  
  showspaces=false,                
  showstringspaces=false,
  showtabs=false,                  
  tabsize=2
}
}
{}

\lstset{aboveskip=10pt,belowskip=10pt}

\begin{document}

\chapter{Introduction}

This is a guide for C++.

\chapter{Initializations}

\section{Braced Initialization}

\begin{cpp}
int x = 0;
int x = 42;
int x = {};
int x = {42};
int x{};
int x{42};
\end{cpp}

\chapter{Constructors}

When does C++ supply constructors?

\begin{enumerate}
\item The compiler creates a default constructor.
\item The compiler also creates a copy constructor for us by copying all data members.
\item The compiler doesn't create a default constructor if we supply any constructor.
\item The compiler creates a copy constructor if we don't supply our own, even if we've writtern other constructors.
\end{enumerate}

\section{Copy Constructor}
\begin{cpp}
  
  vector(const vector& v) : my_size{v.my_size}, data{new double[my_size]}
  {
    for (unsigned i = 0; i < my_size; i++) {
      data[i] = v.data[i];
    }
    
\end{cpp}

\chapter{Type Traits}

\begin{cpp}

  #include <type_traits>

  template <typename T>
  void foo(T) {
    std::cout << ``T is signed'' << std::endl;
  }

  template <class T, class = typename std::enable_if<std::is_unsigned<T>::value>::type>
  void foo(T) {
    std::cout << ``T is unsigned'' << std::endl;
  }

  struct A {};
  struct B : A {};

  template <class T, class = typename std::enable_if<std::is_base_of<A, T>::<value>::type>
  struct C : T {};
    
\end{cpp}

\end{document}




 	
